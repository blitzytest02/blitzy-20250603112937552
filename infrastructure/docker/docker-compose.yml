# =============================================================================
# DOCKER COMPOSE CONFIGURATION - Python Flask Tutorial Application
# =============================================================================
# Multi-environment container orchestration for Flask web server with Python 3.12+
# Educational demonstration of Docker Compose patterns with Flask framework
# 
# Purpose: Containerized deployment orchestration for development and production
# Learning Objectives: Multi-service configuration, environment management, networking
# Technical Stack: Docker Compose v3.8, Python 3.12+, Flask 3.1.1+, Gunicorn 21.2.0+
# 
# Usage:
#   Development: docker-compose up flask-tutorial-dev
#   Production:  docker-compose up flask-tutorial-prod  
#   Testing:     docker-compose run --rm flask-tutorial-dev pytest
#   Both:        docker-compose up flask-tutorial-dev flask-tutorial-prod
# =============================================================================

version: '3.8'

# =============================================================================
# SERVICE DEFINITIONS
# =============================================================================
# Defines containerized services for development and production environments
# Each service uses multi-stage Docker build targets for optimized Python deployment
# Implements container security, resource management, and monitoring best practices

services:
  # ===========================================================================
  # DEVELOPMENT SERVICE CONFIGURATION
  # ===========================================================================
  # Development service with source code mounting, Python debugging capabilities,
  # and comprehensive development tooling for educational Flask workflow demonstration
  
  flask-tutorial-dev:
    # Container identification and metadata
    container_name: flask-tutorial-dev
    hostname: flask-tutorial-dev
    
    # Multi-stage build configuration targeting Python development stage
    build:
      context: ../../
      dockerfile: infrastructure/docker/Dockerfile
      target: development
      # Build arguments for Python development optimization
      args:
        - FLASK_ENV=development
        - PYTHON_VERSION=3.12
        - BUILD_DATE=${BUILD_DATE:-}
        - VCS_REF=${VCS_REF:-}
      # Build caching strategy for Python development efficiency
      cache_from:
        - python:3.12-alpine
        - flask-tutorial:dev-cache
    
    # Development environment variables for Flask educational transparency
    environment:
      # Flask runtime configuration
      FLASK_ENV: development
      FLASK_APP: app.py
      FLASK_DEBUG: 1
      PORT: 3000
      HOST: 0.0.0.0
      
      # Python runtime configuration
      PYTHON_VERSION: 3.12
      PYTHONPATH: /usr/src/app
      PYTHONUNBUFFERED: 1
      PYTHONDONTWRITEBYTECODE: 1
      
      # Development-specific logging and debugging
      LOG_LEVEL: debug
      
      # pip configuration for development workflow
      PIP_NO_CACHE_DIR: 0
      PIP_DISABLE_PIP_VERSION_CHECK: 0
      
      # Educational environment metadata
      TUTORIAL_MODE: development
      COMPOSE_SERVICE: flask-tutorial-dev
    
    # Port mapping for development access and Python debugging
    ports:
      - "3000:3000"     # HTTP server port for Flask application access
      - "5678:5678"     # Python debugpy port for IDE integration
    
    # Volume configuration for Python development workflow
    volumes:
      # Source code hot-reloading with delegated consistency for macOS performance
      - type: bind
        source: ../../src/backend
        target: /usr/src/app
        consistency: delegated
        
      # Anonymous volume for Python __pycache__ to prevent host override
      - type: volume
        target: /usr/src/app/__pycache__
        
      # Named volume for persistent Python virtual environment caching
      - type: volume
        source: venv_cache_dev
        target: /usr/src/app/.venv
    
    # Network configuration for service isolation and discovery
    networks:
      - flask-tutorial-network
    
    # Restart policy for development stability
    restart: unless-stopped
    
    # Development startup command with Python debugging and Flask hot-reload capabilities
    command: >
      sh -c "
        echo 'üéì Starting Python Flask Tutorial Development Server...' &&
        echo 'üìã Development Features: Hot-reload, Debug mode, pytest testing, black/flake8 linting' &&
        echo 'üîß Access: http://localhost:3000/hello' &&
        echo 'üêõ Debug: Configure IDE to connect to debugpy on port 5678' &&
        echo 'üß™ Testing: docker-compose exec flask-tutorial-dev pytest' &&
        echo 'üé® Format: docker-compose exec flask-tutorial-dev black .' &&
        echo 'üîç Lint: docker-compose exec flask-tutorial-dev flake8' &&
        pip install -e . &&
        python -m debugpy --listen 0.0.0.0:5678 --wait-for-client app.py
      "
    
    # Health check configuration for Flask development monitoring
    healthcheck:
      test: 
        - CMD
        - curl
        - -f
        - http://localhost:3000/hello
      interval: 15s      # Frequent checks for development feedback
      timeout: 5s        # Quick timeout for development responsiveness
      retries: 3         # Limited retries for development workflow
      start_period: 10s  # Allow time for Flask development server startup
    
    # Development-specific labels for container identification
    labels:
      - "tutorial.environment=development"
      - "tutorial.service=flask-tutorial-dev"
      - "tutorial.version=1.0.0"
      - "tutorial.purpose=educational-development"
      - "tutorial.framework=flask.3.1.1"
      - "tutorial.runtime=python.3.12"
      - "tutorial.wsgi=gunicorn.21.2.0"
    
    # Security configuration for development environment
    security_opt:
      - no-new-privileges:true
    
    # User configuration for non-root execution
    user: "1000:1000"  # app user from Dockerfile
    
    # Working directory specification
    working_dir: /usr/src/app
    
    # TTY and interactive mode for development debugging
    tty: true
    stdin_open: true
    
    # Dependency configuration for service startup order
    depends_on:
      - flask-network-setup

  # ===========================================================================
  # PRODUCTION SERVICE CONFIGURATION  
  # ===========================================================================
  # Production service with optimized Python container, resource limits, security hardening,
  # and Gunicorn WSGI server performance tuning for production deployment demonstration
  
  flask-tutorial-prod:
    # Container identification and metadata
    container_name: flask-tutorial-prod
    hostname: flask-tutorial-prod
    
    # Multi-stage build configuration targeting Python production stage
    build:
      context: ../../
      dockerfile: infrastructure/docker/Dockerfile
      target: production
      # Build arguments for Python production optimization
      args:
        - FLASK_ENV=production
        - PYTHON_VERSION=3.12
        - BUILD_DATE=${BUILD_DATE:-}
        - VCS_REF=${VCS_REF:-}
      # Build caching strategy for Python production efficiency
      cache_from:
        - python:3.12-alpine
        - flask-tutorial:prod-cache
    
    # Production environment variables for optimal Flask performance
    environment:
      # Flask runtime configuration for production
      FLASK_ENV: production
      FLASK_APP: wsgi:app
      FLASK_DEBUG: 0
      PORT: 3000
      HOST: 0.0.0.0
      
      # Python runtime configuration
      PYTHON_VERSION: 3.12
      PYTHONPATH: /usr/src/app
      PYTHONUNBUFFERED: 1
      PYTHONDONTWRITEBYTECODE: 1
      
      # Production logging configuration
      LOG_LEVEL: info
      
      # pip configuration for production
      PIP_NO_CACHE_DIR: 1
      PIP_DISABLE_PIP_VERSION_CHECK: 1
      
      # Gunicorn WSGI server configuration
      GUNICORN_WORKERS: 4
      GUNICORN_THREADS: 2
      GUNICORN_TIMEOUT: 30
      GUNICORN_KEEPALIVE: 2
      GUNICORN_BIND: 0.0.0.0:3000
      
      # Python performance optimization settings
      PYTHONOPTIMIZE: 2
      
      # Educational environment metadata
      TUTORIAL_MODE: production
      COMPOSE_SERVICE: flask-tutorial-prod
    
    # Port mapping for production access (different port to avoid dev conflicts)
    ports:
      - "3001:3000"     # HTTP server port mapped to 3001 externally
    
    # Volume configuration for production (no source mounting)
    volumes:
      # Named volume for Python virtual environment caching (read-only)
      - type: volume
        source: venv_cache_prod
        target: /usr/src/app/.venv
        read_only: true
    
    # Network configuration for service isolation
    networks:
      - flask-tutorial-network
    
    # Restart policy for production stability
    restart: always
    
    # Production startup command optimized for Gunicorn WSGI server performance
    command: >
      sh -c "
        echo 'üöÄ Starting Python Flask Tutorial Production Server...' &&
        echo 'üìã Production Features: Gunicorn WSGI, Resource limits, Security hardening, Performance optimization' &&
        echo 'üîß Access: http://localhost:3001/hello' &&
        echo 'üìä Resource limits: 128MB memory, 0.5 CPU cores' &&
        echo '‚öôÔ∏è  Gunicorn workers: 4, threads: 2' &&
        gunicorn wsgi:app --bind 0.0.0.0:3000 --workers 4 --threads 2 --timeout 30 --keepalive 2 --access-logfile - --error-logfile -
      "
    
    # Health check configuration for Flask production monitoring
    healthcheck:
      test:
        - CMD
        - curl
        - -f
        - http://localhost:3000/hello
      interval: 30s      # Standard production monitoring interval
      timeout: 10s       # Reasonable timeout for Flask production response
      retries: 3         # Standard retry count for production reliability
      start_period: 15s  # Allow time for Gunicorn server initialization
    
    # Resource limits for Python production deployment demonstration
    deploy:
      resources:
        limits:
          memory: 128M          # Educational memory constraint for Python runtime awareness
          cpus: '0.5'          # Half CPU core limit for performance testing
        reservations:
          memory: 64M           # Guaranteed memory allocation for Python baseline performance
          cpus: '0.25'         # Quarter CPU core reservation for consistent performance
      
      # Production deployment configuration
      replicas: 1
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback
        monitor: 60s
      restart_policy:
        condition: any
        delay: 5s
        max_attempts: 3
        window: 120s
    
    # Production-specific labels for container identification
    labels:
      - "tutorial.environment=production"
      - "tutorial.service=flask-tutorial-prod"
      - "tutorial.version=1.0.0"
      - "tutorial.purpose=educational-production"
      - "tutorial.framework=flask.3.1.1"
      - "tutorial.runtime=python.3.12"
      - "tutorial.wsgi=gunicorn.21.2.0"
      - "tutorial.optimization=performance"
      - "tutorial.security=hardened"
    
    # Enhanced security configuration for production
    security_opt:
      - no-new-privileges:true
      - apparmor:unconfined  # Educational: would be configured properly in real production
    
    # User configuration for non-root execution
    user: "1000:1000"  # app user from Dockerfile
    
    # Working directory specification
    working_dir: /usr/src/app
    
    # Read-only root filesystem for security (with exceptions for writable areas)
    read_only: true
    tmpfs:
      - /tmp:rw,size=10M,mode=1777
      - /var/tmp:rw,size=10M,mode=1777
    
    # Capability dropping for security hardening
    cap_drop:
      - ALL
    cap_add:
      - SETGID
      - SETUID
    
    # Dependency configuration for service startup order
    depends_on:
      - flask-network-setup

  # ===========================================================================
  # NETWORK SETUP SERVICE
  # ===========================================================================
  # Utility service for network initialization and educational demonstration
  
  flask-network-setup:
    image: alpine:3.19
    container_name: flask-network-setup
    command: >
      sh -c "
        echo 'üåê Initializing Flask tutorial network infrastructure...' &&
        echo 'üìã Network: flask-tutorial-network (bridge driver)' &&
        echo 'üîß Services: flask-tutorial-dev, flask-tutorial-prod' &&
        echo '‚úÖ Network setup complete' &&
        sleep 2
      "
    networks:
      - flask-tutorial-network
    labels:
      - "tutorial.utility=network-setup"
      - "tutorial.purpose=educational"

# =============================================================================
# NETWORK CONFIGURATION
# =============================================================================
# Custom bridge network for service isolation and educational Flask networking demonstration

networks:
  flask-tutorial-network:
    # Custom bridge network for service isolation
    driver: bridge
    name: flask-tutorial-network
    
    # Network configuration for educational transparency
    driver_opts:
      com.docker.network.bridge.name: flask-br0
      com.docker.network.bridge.enable_ip_masquerade: "true"
      com.docker.network.bridge.enable_icc: "true"
      com.docker.network.bridge.host_binding_ipv4: "0.0.0.0"
    
    # IP address management configuration
    ipam:
      driver: default
      config:
        - subnet: 172.21.0.0/16
          gateway: 172.21.0.1
          ip_range: 172.21.240.0/20
    
    # Network labels for identification and management
    labels:
      - "tutorial.network=true"
      - "tutorial.purpose=service-isolation"
      - "tutorial.driver=bridge"
      - "tutorial.educational=container-networking"
      - "tutorial.framework=flask"

# =============================================================================
# VOLUME CONFIGURATION
# =============================================================================
# Named volumes for Python virtual environment caching and persistent data management

volumes:
  # Development environment Python virtual environment cache
  venv_cache_dev:
    driver: local
    name: flask-tutorial-venv-dev
    labels:
      - "tutorial.volume=venv-dev-cache"
      - "tutorial.purpose=python-dependency-caching"
      - "tutorial.environment=development"
      - "tutorial.framework=flask"
  
  # Production environment Python virtual environment cache
  venv_cache_prod:
    driver: local
    name: flask-tutorial-venv-prod
    labels:
      - "tutorial.volume=venv-prod-cache"
      - "tutorial.purpose=python-dependency-caching"
      - "tutorial.environment=production"
      - "tutorial.framework=flask"
  
  # Shared volume for educational data persistence demonstration
  flask_shared_data:
    driver: local
    name: flask-tutorial-shared
    driver_opts:
      type: none
      o: bind
      device: ${PWD}/data
    labels:
      - "tutorial.volume=shared-data"
      - "tutorial.purpose=educational-persistence"
      - "tutorial.accessibility=cross-service"
      - "tutorial.framework=flask"

# =============================================================================
# EDUCATIONAL DOCKER COMPOSE PATTERNS DEMONSTRATION - PYTHON FLASK EDITION
# =============================================================================
# This Docker Compose configuration demonstrates key concepts for Python Flask container orchestration:
#
# 1. MULTI-ENVIRONMENT FLASK SERVICES:
#    - Development service with hot-reloading and Python debugging capabilities
#    - Production service with Gunicorn WSGI server and optimized performance
#    - Demonstrates environment-specific Flask configuration patterns
#
# 2. PYTHON CONTAINER NETWORKING:
#    - Custom bridge network for Flask service isolation
#    - Service discovery through container names
#    - Network security through isolated communication
#
# 3. PYTHON VOLUME MANAGEMENT:
#    - Source code mounting for Flask development workflow
#    - Virtual environment caching for pip performance optimization
#    - Anonymous volumes to prevent Python __pycache__ host interference
#
# 4. PYTHON SECURITY IMPLEMENTATION:
#    - Non-root user execution in all Python containers
#    - Security options and capability management
#    - Read-only filesystem for Flask production hardening
#
# 5. RESOURCE MANAGEMENT FOR PYTHON:
#    - Memory and CPU limits for Python production deployment
#    - Resource reservations for guaranteed Flask performance
#    - Educational resource constraints for Python runtime learning
#
# 6. FLASK HEALTH MONITORING:
#    - HTTP endpoint health checks for Flask service availability
#    - Environment-specific health check configurations
#    - Container restart policies based on Flask health status
#
# 7. PYTHON BUILD OPTIMIZATION:
#    - Multi-stage Docker builds with different Python targets
#    - Build caching strategies for faster Python rebuilds
#    - Context optimization through .dockerignore patterns
#
# 8. OPERATIONAL PATTERNS FOR FLASK:
#    - Service dependencies and startup ordering
#    - Graceful shutdown handling for Gunicorn WSGI server
#    - Educational logging and transparency for Python applications
#
# LEARNING COMMANDS FOR PYTHON FLASK:
# ===================================
# View service status:     docker-compose ps
# Follow service logs:     docker-compose logs -f [service-name]
# Execute into container:  docker-compose exec [service-name] sh
# Scale services:          docker-compose up --scale flask-tutorial-dev=2
# Network inspection:      docker network inspect flask-tutorial-network
# Volume inspection:       docker volume inspect flask-tutorial-venv-dev
# Resource monitoring:     docker stats $(docker-compose ps -q)
# Clean shutdown:          docker-compose down --volumes --remove-orphans
#
# PYTHON DEVELOPMENT WORKFLOW:
# ============================
# 1. Start development:    docker-compose up flask-tutorial-dev
# 2. View application:     http://localhost:3000/hello
# 3. Edit source code:     Files in src/backend/ automatically reload with Flask debug mode
# 4. Run tests:            docker-compose exec flask-tutorial-dev pytest
# 5. Format code:          docker-compose exec flask-tutorial-dev black .
# 6. Lint code:            docker-compose exec flask-tutorial-dev flake8
# 7. Security scan:        docker-compose exec flask-tutorial-dev bandit -r .
# 8. Debug application:    Configure IDE to connect to debugpy on port 5678
#
# FLASK PRODUCTION TESTING:
# =========================
# 1. Start production:     docker-compose up flask-tutorial-prod
# 2. View application:     http://localhost:3001/hello
# 3. Monitor resources:    docker stats flask-tutorial-prod
# 4. Check health:         docker-compose exec flask-tutorial-prod curl localhost:3000/hello
# 5. Scale testing:        docker-compose up --scale flask-tutorial-prod=3
# 6. Gunicorn workers:     Check logs for worker process management
#
# PYTHON SECURITY VERIFICATION:
# ==============================
# 1. User verification:    docker-compose exec flask-tutorial-prod whoami
# 2. Capability check:     docker-compose exec flask-tutorial-prod cat /proc/self/status | grep Cap
# 3. Filesystem check:     docker-compose exec flask-tutorial-prod touch /test-readonly
# 4. Network isolation:    docker-compose exec flask-tutorial-prod ping flask-tutorial-dev
# 5. Python packages:      docker-compose exec flask-tutorial-prod pip list
# 6. Flask configuration:  docker-compose exec flask-tutorial-dev python -c "from app import create_app; print(create_app().config)"
#
# PYTHON TESTING AND QUALITY COMMANDS:
# ====================================
# 1. Run all tests:        docker-compose exec flask-tutorial-dev pytest
# 2. Test with coverage:   docker-compose exec flask-tutorial-dev pytest --cov=app --cov-report=html
# 3. Performance tests:    docker-compose exec flask-tutorial-dev pytest -k "performance"
# 4. Security analysis:    docker-compose exec flask-tutorial-dev bandit -r . -f json
# 5. Dependency check:     docker-compose exec flask-tutorial-dev safety check
# 6. Type checking:        docker-compose exec flask-tutorial-dev mypy app.py
# 7. Import sorting:       docker-compose exec flask-tutorial-dev isort . --check-only
#
# GUNICORN WSGI SERVER CONFIGURATION:
# ===================================
# Workers: 4 (optimal for educational CPU constraints)
# Threads: 2 per worker (balance between concurrency and memory)
# Timeout: 30s (reasonable for educational response times)
# Keepalive: 2s (efficient connection reuse)
# Bind: 0.0.0.0:3000 (container-internal binding)
#
# FLASK DEBUGGING AND DEVELOPMENT:
# ================================
# - Flask debug mode enabled in development with FLASK_DEBUG=1
# - Python debugpy server on port 5678 for IDE integration
# - Hot-reload capability through Flask's built-in development server
# - Comprehensive error pages with stack traces in development
# - Real-time code reloading without container restart
#
# PYTHON EDUCATIONAL PATTERNS:
# ============================
# - Virtual environment management and caching patterns
# - Python package management with pip and requirements.txt
# - Flask application factory pattern demonstration
# - WSGI server deployment with Gunicorn
# - Python-specific containerization best practices
# - pytest testing framework integration
# - Python code quality tools (black, flake8, bandit, safety)
# - Python performance monitoring and optimization techniques
#
# =============================================================================