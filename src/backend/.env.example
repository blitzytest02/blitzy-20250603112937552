# =============================================================================
# PYTHON FLASK TUTORIAL APPLICATION - ENVIRONMENT CONFIGURATION TEMPLATE
# =============================================================================
# 
# This file provides a template for environment variable configuration for the
# Python Flask tutorial application featuring a single /hello endpoint.
# 
# SETUP INSTRUCTIONS:
# 1. Copy this file to .env in the same directory
# 2. Modify values according to your local development needs
# 3. Ensure .env file is listed in .gitignore to prevent version control inclusion
# 4. Start application with 'python wsgi.py' or 'flask run' to load environment variables automatically
#
# SECURITY NOTE: This template contains only example values, no actual secrets
# or credentials. The .env file should never be committed to version control.
#
# =============================================================================

# =============================================================================
# SERVER CONFIGURATION
# =============================================================================

# Server Port Configuration
# Description: HTTP server port number for Flask application binding
# Default: 5000 (Flask's default development port)
# Validation: Integer between 1024-65535 (non-privileged ports)
# Usage: os.environ.get('PORT', 5000) in Flask application
# 
# DEPLOYMENT NOTES:
# - Heroku: PORT automatically provided by Heroku platform
# - Render: PORT automatically provided by Render platform  
# - Railway: PORT automatically provided by Railway platform
# - Azure Web Apps: PORT automatically provided by Azure platform
# - Docker: Environment variable passed through container runtime
# - VPS: Manual configuration required on virtual private servers
#
# SECURITY: Port validation prevents binding to privileged ports without permission
PORT=5000

# Server Host Configuration
# Description: Server host address for HTTP server binding
# Default: localhost (local development only)
# Validation: Valid hostname, IP address, or 0.0.0.0 for all interfaces
# Usage: Flask development server host configuration and Gunicorn binding
#
# DEPLOYMENT NOTES:
# - Local Development: Use 'localhost' for security
# - Container Deployment: Use '0.0.0.0' for accessibility across container networks
# - Production: Consider specific interface binding for security
#
# SECURITY: Host binding controls network interface access for security
HOST=localhost

# =============================================================================
# FLASK APPLICATION CONFIGURATION
# =============================================================================

# Flask Environment Mode
# Description: Flask environment mode affecting application behavior and optimizations
# Default: development (full error messages, debug mode, auto-reload)
# Validation: 'development', 'production', 'testing'
# Usage: Flask application factory configuration and environment-specific optimizations
#
# BEHAVIOR BY ENVIRONMENT:
# - development: Detailed error messages, debug mode enabled, template auto-reload
# - production: Generic error messages, debug mode disabled, optimized performance
# - testing: Testing-specific configurations, reduced logging, test database
#
# DEPLOYMENT NOTES:
# - Set to 'production' for all deployment environments
# - Affects Flask's debug mode, error handling, and template caching behavior
# - Enables/disables Flask's development server features and security warnings
#
# SECURITY: Prevents information disclosure in production environments
FLASK_ENV=development

# Flask Debug Mode Configuration
# Description: Flask debug mode enabling interactive debugger and auto-reload
# Default: True (development convenience)
# Validation: 'True', 'False', '1', '0' (case-insensitive boolean)
# Usage: Flask application factory debug configuration
#
# DEBUG MODE FEATURES:
# - Interactive web-based debugger for exceptions
# - Automatic application reloading on code changes
# - Enhanced error pages with stack traces and local variables
# - Template auto-reloading without server restart
#
# DEPLOYMENT NOTES:
# - MUST be set to 'False' in production for security
# - Development: 'True' for enhanced debugging experience
# - Testing: 'False' to match production behavior
# - Debug mode should never be enabled in publicly accessible environments
#
# SECURITY: Debug mode exposes sensitive information and poses security risks
FLASK_DEBUG=True

# =============================================================================
# PRODUCTION WSGI SERVER CONFIGURATION
# =============================================================================

# Gunicorn Worker Process Configuration
# Description: Number of worker processes for Gunicorn WSGI server
# Default: 1 (single worker for tutorial simplicity)
# Validation: Positive integer, typically 2-4x CPU cores
# Usage: Gunicorn startup configuration for production deployment
#
# WORKER CALCULATION GUIDELINES:
# - Formula: (2 × CPU cores) + 1 for optimal performance
# - Minimum: 1 worker for basic functionality
# - Maximum: Limited by available memory (each worker ~75MB for Flask)
# - Container: Consider container resource limits
#
# DEPLOYMENT NOTES:
# - Single worker sufficient for tutorial and low-traffic applications
# - Multiple workers provide concurrency and fault tolerance
# - More workers increase memory usage but improve request handling
# - Adjust based on application memory footprint and traffic patterns
#
# MEMORY CONSIDERATIONS:
# - Each worker process consumes approximately 75MB of memory
# - Total memory = (WORKERS × 75MB) + overhead
# - Container memory limits should accommodate worker count
WORKERS=1

# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================

# Application Logging Level
# Description: Application logging level controlling console output verbosity
# Default: INFO (balanced information for development)
# Validation: 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL' (case-insensitive)
# Usage: Python logging module configuration and Flask application logging
#
# LOG LEVEL HIERARCHY (lowest to highest verbosity):
# - CRITICAL: Only critical errors that require immediate attention
# - ERROR: Error conditions that require attention but don't stop execution
# - WARNING: Warning conditions that should be addressed but don't affect operation
# - INFO: General informational messages about application operation
# - DEBUG: Detailed debugging information for development troubleshooting
#
# DEPLOYMENT NOTES:
# - Use 'ERROR' or 'WARNING' for production environments to reduce log noise
# - 'DEBUG' level may expose sensitive information and impact performance
# - Higher verbosity levels may affect application performance in production
# - Consider structured logging for production environments
#
# SECURITY: Debug level may expose sensitive information in application logs
LOG_LEVEL=INFO

# =============================================================================
# PYTHON-SPECIFIC CONFIGURATION
# =============================================================================

# Python Path Configuration
# Description: Additional Python module search paths for application imports
# Default: Not set (uses default Python path resolution)
# Validation: Colon-separated list of directory paths (Unix) or semicolon-separated (Windows)
# Usage: sys.path modification for custom module locations
#
# PYTHONPATH NOTES:
# - Useful for custom package imports or development setups
# - Not typically required for standard Flask application structure
# - Can be used to add src/ directory to Python path for imports
# - Alternative to setuptools development installation
#
# EXAMPLE: PYTHONPATH=/app/src:/app/lib for custom module paths
# PYTHONPATH=

# Python Optimization Level
# Description: Python bytecode optimization level for performance tuning
# Default: 0 (no optimization, keeps assertions and debug info)
# Validation: 0, 1, or 2 (integer optimization levels)
# Usage: Python interpreter startup optimization configuration
#
# OPTIMIZATION LEVELS:
# - 0: No optimization, assertions enabled, __debug__ is True
# - 1: Basic optimization, assertions disabled, __debug__ is False
# - 2: Extended optimization, removes docstrings and additional optimizations
#
# DEPLOYMENT NOTES:
# - Use 0 for development to enable assertions and debugging
# - Use 1 for production to disable assertions while keeping docstrings
# - Use 2 for production when memory/performance optimization is critical
#
# TRADE-OFFS: Higher levels improve performance but reduce debugging capabilities
PYTHONOPTIMIZE=0

# =============================================================================
# EDUCATIONAL CONFIGURATION EXAMPLES
# =============================================================================
#
# The following examples demonstrate additional environment variable patterns
# commonly used in Python Flask applications. These are commented out as they are
# not required for the basic tutorial application.

# Database Configuration Example (not used in tutorial)
# DATABASE_URL=postgresql://user:password@localhost:5432/tutorial_app
# SQLALCHEMY_DATABASE_URI=postgresql://user:password@localhost:5432/tutorial_app
# SQLALCHEMY_TRACK_MODIFICATIONS=False

# Authentication Configuration Example (not used in tutorial)  
# SECRET_KEY=your-super-secret-flask-key-here-change-in-production
# JWT_SECRET_KEY=your-jwt-secret-key-here
# JWT_ACCESS_TOKEN_EXPIRES=86400

# External API Configuration Example (not used in tutorial)
# API_BASE_URL=https://api.example.com
# API_KEY=your-api-key-here
# API_TIMEOUT=30

# Redis Configuration Example (not used in tutorial)
# REDIS_URL=redis://localhost:6379/0
# CELERY_BROKER_URL=redis://localhost:6379/0
# CELERY_RESULT_BACKEND=redis://localhost:6379/0

# Flask-specific Configuration Examples (not used in tutorial)
# FLASK_APP=wsgi.py
# FLASK_RUN_HOST=0.0.0.0
# FLASK_RUN_PORT=5000
# MAX_CONTENT_LENGTH=16777216

# =============================================================================
# PLATFORM-SPECIFIC DEPLOYMENT EXAMPLES
# =============================================================================

# Azure Web Apps Platform Example:
# PORT=8000 (automatically set by Azure)
# FLASK_ENV=production
# FLASK_DEBUG=False
# LOG_LEVEL=WARNING
# WORKERS=2

# Heroku Platform Example:
# PORT=5000 (automatically set by Heroku)
# FLASK_ENV=production
# FLASK_DEBUG=False
# LOG_LEVEL=ERROR
# WORKERS=3

# Render Platform Example:
# PORT=10000 (automatically set by Render)
# FLASK_ENV=production
# FLASK_DEBUG=False
# LOG_LEVEL=INFO
# WORKERS=2

# Railway Platform Example:
# PORT=3333 (automatically set by Railway)
# FLASK_ENV=production
# FLASK_DEBUG=False
# LOG_LEVEL=WARNING
# WORKERS=1

# Docker Container Example:
# PORT=5000
# HOST=0.0.0.0
# FLASK_ENV=production
# FLASK_DEBUG=False
# LOG_LEVEL=WARNING
# WORKERS=2
# PYTHONOPTIMIZE=1

# =============================================================================
# VALIDATION GUIDELINES
# =============================================================================
#
# PORT Validation:
# - Must be integer value between 1024-65535
# - Port must be available and not in use by other applications
# - Ports below 1024 require root privileges on Unix systems
#
# FLASK_ENV Validation:
# - Must be one of: 'development', 'production', 'testing'
# - Case-sensitive (lowercase recommended for consistency)
# - Affects Flask behavior, debug mode, and error handling
#
# FLASK_DEBUG Validation:
# - Must be boolean-like: 'True', 'False', '1', '0'
# - Case-insensitive for string values
# - Should be False in production for security
#
# HOST Validation:
# - Must be valid hostname, IP address, or '0.0.0.0'
# - 'localhost' restricts access to local machine only
# - '0.0.0.0' allows access from any network interface
#
# WORKERS Validation:
# - Must be positive integer
# - Consider memory constraints (75MB per worker)
# - Optimal range: 1-8 workers for most applications
#
# LOG_LEVEL Validation:
# - Must be valid Python logging level name
# - Case-insensitive: 'debug', 'info', 'warning', 'error', 'critical'
# - Higher levels include all lower level messages
#
# =============================================================================
# PERFORMANCE CONSIDERATIONS
# =============================================================================
#
# Environment Loading Performance:
# - Startup Time: < 0.2 seconds for environment variable processing with python-dotenv
# - Memory Usage: < 2KB memory overhead for environment variable storage
# - CPU Impact: Negligible CPU usage for environment variable access
#
# Configuration Optimization:
# - FLASK_ENV=production enables Flask optimizations and template caching
# - FLASK_DEBUG=False reduces debugging overhead in production
# - Lower LOG_LEVEL reduces console I/O overhead in production
# - PYTHONOPTIMIZE=1 improves runtime performance
# - Optimal WORKERS count balances concurrency and memory usage
#
# Memory Footprint Targets:
# - Development: Unlimited (debugging and development convenience)
# - Production: <75MB per worker (target for tutorial application)
# - Container: Total memory = (WORKERS × 75MB) + 25MB overhead
#
# =============================================================================
# TROUBLESHOOTING
# =============================================================================
#
# Common Issues:
# 1. Port already in use: Change PORT value or stop conflicting process
# 2. Permission denied: Use port number > 1024 or run with appropriate privileges
# 3. Cannot bind to host: Verify HOST value is valid hostname or IP address
# 4. Environment not loaded: Ensure .env file is in correct directory and python-dotenv is installed
# 5. Flask debug issues: Verify FLASK_DEBUG is proper boolean value
# 6. Worker process issues: Adjust WORKERS count based on available memory
#
# Debugging Steps:
# 1. Verify .env file exists and is readable
# 2. Check that Flask application is loading environment variables via python-dotenv
# 3. Validate environment variable values meet requirements
# 4. Test with default values to isolate configuration issues
# 5. Check Python and Flask version compatibility
# 6. Verify Gunicorn installation for production deployment
#
# Python-specific Debugging:
# 1. Check Python path resolution: python -c "import sys; print(sys.path)"
# 2. Verify Flask installation: python -c "import flask; print(flask.__version__)"
# 3. Test environment loading: python -c "from dotenv import load_dotenv; load_dotenv(); import os; print(os.environ.get('FLASK_ENV'))"
# 4. Check Gunicorn availability: gunicorn --version
#
# =============================================================================
# VERSION COMPATIBILITY
# =============================================================================
#
# Python Compatibility: v3.12+ (recommended for modern language features and performance)
# Flask Compatibility: v3.1.1 (latest stable release with enhanced security)
# Gunicorn Compatibility: v21.0.0+ (production WSGI server for Flask applications)
# python-dotenv Compatibility: v1.0.0+ (environment variable loading)
# Platform Compatibility: Windows, macOS, Linux (cross-platform Python support)
#
# Additional Dependencies:
# - Flask-CORS: v4.0.0+ (cross-origin resource sharing)
# - Werkzeug: Automatically installed with Flask (WSGI utilities)
# - Jinja2: Automatically installed with Flask (template engine)
# - Click: Automatically installed with Flask (CLI commands)
#
# =============================================================================