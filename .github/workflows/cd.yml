# =============================================================================
# CONTINUOUS DEPLOYMENT (CD) PIPELINE - Python Flask Tutorial Application
# =============================================================================
# Automated deployment pipeline for containerized Python Flask tutorial application
# with Flask v3.1.1 demonstrating production-ready deployment patterns
# 
# Educational Focus: Container deployment, security scanning, multi-environment
# deployment strategies, health monitoring, and automated rollback capabilities
# 
# Technical Stack: GitHub Actions, Docker, GitHub Container Registry (ghcr.io),
# Azure Web Apps, Python v3.12+, Flask v3.1.1, Gunicorn WSGI server
# 
# Deployment Flow:
#   CI Pipeline (success) ‚Üí Build & Push Image ‚Üí Security Scan ‚Üí 
#   Deploy Staging ‚Üí Deploy Production ‚Üí Monitor & Validate
# =============================================================================

name: CD Pipeline

# =============================================================================
# WORKFLOW TRIGGERS AND CONDITIONS
# =============================================================================
# CD pipeline activation based on CI success, releases, and manual triggers
# Implements educational deployment patterns with production-ready controls

on:
  # Primary trigger: Successful CI pipeline completion on main branch
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [main]
  
  # Production deployment trigger: GitHub release publication
  release:
    types: [published]
  
  # Manual deployment trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: 'Docker image tag to deploy (default: latest)'
        required: false
        default: 'latest'
        type: string
      skip_tests:
        description: 'Skip security scanning for emergency deployments'
        required: false
        default: false
        type: boolean

# =============================================================================
# CONCURRENCY AND RESOURCE MANAGEMENT
# =============================================================================
# Prevent concurrent deployments to avoid conflicts and resource contention
# Educational demonstration of deployment coordination and safety

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

# =============================================================================
# GLOBAL ENVIRONMENT VARIABLES
# =============================================================================
# Shared configuration for container registry and deployment consistency

env:
  # Container registry configuration
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  
  # Docker optimization flags
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  
  # Flask production configuration
  FLASK_ENV: production
  FLASK_DEBUG: false
  
  # Educational deployment metadata
  TUTORIAL_VERSION: "2.0.0"
  EDUCATIONAL_MODE: "deployment-demonstration"

# =============================================================================
# DEPLOYMENT PIPELINE JOBS
# =============================================================================

jobs:
  # ===========================================================================
  # JOB 1: BUILD AND PUBLISH DOCKER IMAGE
  # ===========================================================================
  # Multi-platform Docker image build with GitHub Container Registry publishing
  # Implements semantic versioning and educational container patterns
  
  build_and_publish:
    name: Build and Publish Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    # Conditional execution: Only run after successful CI or manual trigger
    if: >
      github.event_name == 'workflow_dispatch' || 
      github.event_name == 'release' || 
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    
    # Job outputs for downstream deployment jobs
    outputs:
      image_digest: ${{ steps.build.outputs.digest }}
      image_tags: ${{ steps.meta.outputs.tags }}
      image_labels: ${{ steps.meta.outputs.labels }}
      registry_url: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      deployment_version: ${{ steps.version.outputs.version }}
    
    steps:
      # Step 1: Repository checkout with full git history
      - name: Checkout Repository
        uses: actions/checkout@v4 # GitHub Actions v4
        with:
          fetch-depth: 0  # Full history for proper versioning
          token: ${{ secrets.GITHUB_TOKEN }}
      
      # Step 2: Extract version information for deployment tracking
      - name: Extract Version Information
        id: version
        run: |
          # Extract version from requirements.txt for deployment tracking
          VERSION=$(grep -E "^Flask==" requirements.txt | sed 's/Flask==\([0-9.]*\).*/\1/' || echo "3.1.1")
          COMMIT_SHA=${GITHUB_SHA:0:7}
          BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
          
          # Educational logging for deployment transparency
          echo "üì¶ Flask Version: $VERSION"
          echo "üîó Commit SHA: $COMMIT_SHA"
          echo "üìÖ Build Date: $BUILD_DATE"
      
      # Step 3: Setup Python for pip cache optimization
      - name: Setup Python
        uses: actions/setup-python@v5 # Python Setup v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: 'requirements.txt'
      
      # Step 4: Setup Docker Buildx for advanced build capabilities
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3 # Docker Buildx v3
        with:
          version: latest
          driver-opts: |
            network=host
          platforms: linux/amd64,linux/arm64
          install: true
      
      # Step 5: Authenticate with GitHub Container Registry
      - name: Login to Container Registry
        uses: docker/login-action@v3 # Docker Login v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      # Step 6: Extract Docker image metadata and tags
      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5 # Docker Metadata v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # Branch-based tagging for development tracking
            type=ref,event=branch,suffix=-python
            type=ref,event=pr,suffix=-python
            
            # SHA-based tagging for deployment traceability
            type=sha,prefix={{branch}}-python-,suffix=-{{date 'YYYYMMDD-HHmmss'}}
            
            # Version-based tagging for release management
            type=semver,pattern={{version}}-python
            type=semver,pattern={{major}}.{{minor}}-python
            type=semver,pattern={{major}}-python
            
            # Latest tag for main branch with python suffix
            type=raw,value=latest-python,enable={{is_default_branch}}
            
            # Educational deployment tags
            type=raw,value=tutorial-python-{{date 'YYYYMMDD'}},enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=Python Flask Tutorial Application
            org.opencontainers.image.description=Educational Python Flask HTTP server with Flask v3.1.1
            org.opencontainers.image.vendor=Tutorial Project
            org.opencontainers.image.version=${{ steps.version.outputs.version }}
            org.opencontainers.image.created=${{ steps.version.outputs.build_date }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}#readme
            tutorial.framework=flask
            tutorial.runtime=python
            tutorial.version=3.1.1
            tutorial.educational=true
      
      # Step 7: Build and push multi-platform Docker image
      - name: Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v5 # Docker Build Push v5
        with:
          context: .
          file: infrastructure/docker/Dockerfile
          target: production
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          
          # Build optimization with layer caching
          cache-from: type=gha
          cache-to: type=gha,mode=max
          
          # Build arguments for educational transparency
          build-args: |
            FLASK_ENV=production
            BUILD_DATE=${{ steps.version.outputs.build_date }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.version.outputs.version }}
          
          # Provenance and SBOM generation for security
          provenance: true
          sbom: true
      
      # Step 8: Display build information for educational purposes
      - name: Display Build Information
        run: |
          echo "üèóÔ∏è Docker Image Build Completed Successfully"
          echo ""
          echo "üìä Build Summary:"
          echo "  ‚Ä¢ Image Digest: ${{ steps.build.outputs.digest }}"
          echo "  ‚Ä¢ Registry: ${{ env.REGISTRY }}"
          echo "  ‚Ä¢ Repository: ${{ env.IMAGE_NAME }}"
          echo "  ‚Ä¢ Flask Version: ${{ steps.version.outputs.version }}"
          echo "  ‚Ä¢ Platforms: linux/amd64, linux/arm64"
          echo "  ‚Ä¢ Base Image: python:3.12-alpine"
          echo ""
          echo "üè∑Ô∏è Image Tags:"
          echo "${{ steps.meta.outputs.tags }}" | sed 's/^/  ‚Ä¢ /'
          echo ""
          echo "üì¶ Next Steps: Python security scanning and Flask deployment validation"

  # ===========================================================================
  # JOB 2: CONTAINER SECURITY SCANNING
  # ===========================================================================
  # Comprehensive security analysis of built Docker image using multiple scanners
  # Educational demonstration of container security validation in CI/CD pipelines
  
  security_scan:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [build_and_publish]
    
    # Conditional execution: Skip for emergency deployments or run for all builds
    if: >
      github.event.inputs.skip_tests != 'true' &&
      (github.event_name == 'workflow_dispatch' || 
       github.event_name == 'release' || 
       github.event_name == 'workflow_run')
    
    # Security scan outputs for quality gates
    outputs:
      scan_result: ${{ steps.scan.outputs.result }}
      vulnerability_count: ${{ steps.scan.outputs.vulnerability_count }}
      critical_count: ${{ steps.scan.outputs.critical_count }}
      high_count: ${{ steps.scan.outputs.high_count }}
      python_security_issues: ${{ steps.python_security.outputs.issues_count }}
    
    steps:
      # Step 1: Repository checkout for security context
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      # Step 2: Setup Python for security scanning tools
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: 'requirements.txt'
      
      # Step 3: Install Python security scanning tools
      - name: Install Security Tools
        run: |
          pip install bandit[toml] safety
          echo "üîí Installed Python security scanning tools:"
          echo "  ‚Ä¢ bandit: $(bandit --version)"
          echo "  ‚Ä¢ safety: $(safety --version)"
      
      # Step 4: Run Bandit static security analysis for Python code
      - name: Run Bandit Security Analysis
        id: bandit
        run: |
          echo "üîç Running Bandit static security analysis on Python code..."
          bandit -r src/backend/ -f json -o bandit-results.json || true
          bandit -r src/backend/ -f txt || BANDIT_EXIT_CODE=$?
          
          # Parse results for educational reporting
          if [ -f bandit-results.json ]; then
            ISSUES_COUNT=$(jq '.results | length' bandit-results.json 2>/dev/null || echo "0")
            HIGH_ISSUES=$(jq '[.results[] | select(.issue_severity == "HIGH")] | length' bandit-results.json 2>/dev/null || echo "0")
            echo "issues_count=$ISSUES_COUNT" >> $GITHUB_OUTPUT
            echo "high_issues=$HIGH_ISSUES" >> $GITHUB_OUTPUT
            
            echo "üîí Bandit Security Analysis Results:"
            echo "  ‚Ä¢ Total Issues: $ISSUES_COUNT"
            echo "  ‚Ä¢ High Severity: $HIGH_ISSUES"
            echo "üéì Educational Note: Bandit detects common Python security issues"
          fi
      
      # Step 5: Run Safety dependency vulnerability scanning
      - name: Run Safety Dependency Scan
        id: safety
        run: |
          echo "üîç Running Safety dependency vulnerability scanning..."
          safety check --json --output safety-results.json || true
          safety check || SAFETY_EXIT_CODE=$?
          
          # Parse results for educational reporting
          if [ -f safety-results.json ]; then
            VULNERABILITIES=$(jq 'length' safety-results.json 2>/dev/null || echo "0")
            echo "vulnerabilities=$VULNERABILITIES" >> $GITHUB_OUTPUT
            
            echo "üîí Safety Dependency Scan Results:"
            echo "  ‚Ä¢ Vulnerabilities Found: $VULNERABILITIES"
            echo "üéì Educational Note: Safety checks for known security vulnerabilities in Python packages"
          fi
      
      # Step 6: Comprehensive container vulnerability scanning
      - name: Run Trivy Vulnerability Scanner
        id: scan
        uses: aquasecurity/trivy-action@master # Trivy Security Scanner
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build_and_publish.outputs.image_digest }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          exit-code: '0'  # Don't fail on vulnerabilities, analyze in next step
        env:
          TRIVY_USERNAME: ${{ github.actor }}
          TRIVY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
      
      # Step 7: Generate comprehensive security summary
      - name: Generate Security Summary
        id: summary
        run: |
          # Parse Trivy results for educational reporting
          if [ -f trivy-results.sarif ]; then
            # Extract vulnerability counts from SARIF format
            CRITICAL=$(jq '[.runs[].results[] | select(.level == "error")] | length' trivy-results.sarif 2>/dev/null || echo "0")
            HIGH=$(jq '[.runs[].results[] | select(.level == "warning")] | length' trivy-results.sarif 2>/dev/null || echo "0")
            MEDIUM=$(jq '[.runs[].results[] | select(.level == "note")] | length' trivy-results.sarif 2>/dev/null || echo "0")
            TOTAL=$((CRITICAL + HIGH + MEDIUM))
            
            echo "critical_count=$CRITICAL" >> $GITHUB_OUTPUT
            echo "high_count=$HIGH" >> $GITHUB_OUTPUT
            echo "medium_count=$MEDIUM" >> $GITHUB_OUTPUT
            echo "total_count=$TOTAL" >> $GITHUB_OUTPUT
            
            # Get Python-specific security counts
            BANDIT_ISSUES=${{ steps.bandit.outputs.issues_count || 0 }}
            SAFETY_VULNS=${{ steps.safety.outputs.vulnerabilities || 0 }}
            
            # Educational security reporting
            echo "üîí Comprehensive Security Scan Results"
            echo ""
            echo "üìä Container Vulnerability Summary:"
            echo "  ‚Ä¢ Critical: $CRITICAL"
            echo "  ‚Ä¢ High: $HIGH"
            echo "  ‚Ä¢ Medium: $MEDIUM"
            echo "  ‚Ä¢ Total: $TOTAL"
            echo ""
            echo "üêç Python-Specific Security Analysis:"
            echo "  ‚Ä¢ Bandit Issues: $BANDIT_ISSUES"
            echo "  ‚Ä¢ Safety Vulnerabilities: $SAFETY_VULNS"
            echo ""
            
            # Security gate evaluation with Python-specific checks
            if [ $CRITICAL -gt 0 ] || [ $SAFETY_VULNS -gt 0 ]; then
              echo "‚ùå Security Gate: FAILED - Critical vulnerabilities detected"
              echo "security_gate=failed" >> $GITHUB_OUTPUT
              exit 1
            elif [ $HIGH -gt 5 ] || [ $BANDIT_ISSUES -gt 3 ]; then
              echo "‚ö†Ô∏è Security Gate: WARNING - High vulnerability count exceeds threshold"
              echo "security_gate=warning" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ Security Gate: PASSED - Vulnerability count within acceptable limits"
              echo "security_gate=passed" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è Security scan results not found"
            echo "security_gate=unknown" >> $GITHUB_OUTPUT
          fi
      
      # Step 8: Upload security results to GitHub Security tab
      - name: Upload Trivy Scan Results
        uses: github/codeql-action/upload-sarif@v2 # CodeQL SARIF Upload v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'container-security'
      
      # Step 9: Archive security scan artifacts
      - name: Upload Security Artifacts
        uses: actions/upload-artifact@v3 # Actions Upload Artifact v3
        if: always()
        with:
          name: python-security-scan-results
          path: |
            trivy-results.sarif
            bandit-results.json
            safety-results.json
          retention-days: 30

  # ===========================================================================
  # JOB 3: STAGING ENVIRONMENT DEPLOYMENT
  # ===========================================================================
  # Automated deployment to staging environment with health validation
  # Educational demonstration of containerized Flask deployment patterns and monitoring
  
  deploy_staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 12
    needs: [build_and_publish, security_scan]
    
    # Environment configuration for GitHub deployment protection
    environment:
      name: staging
      url: https://flask-tutorial-staging.azurewebsites.net
    
    # Staging deployment outputs for production gate
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
      health_check_url: ${{ steps.deploy.outputs.url }}
      deployment_time: ${{ steps.deploy.outputs.timestamp }}
    
    steps:
      # Step 1: Repository checkout for deployment context
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      # Step 2: Setup Python for smoke testing
      - name: Setup Python
        uses: actions/setup-python@v5 # Python Setup v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: 'requirements.txt'
      
      # Step 3: Install dependencies for smoke tests
      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          echo "üì¶ Python dependencies installed for smoke testing"
          echo "üéì Educational Note: Using pip for Python package management"
      
      # Step 4: Deploy container to Azure Web App staging
      - name: Deploy to Azure Web App
        id: deploy
        uses: azure/webapps-deploy@v2 # Azure Web App Deploy v2
        with:
          app-name: 'flask-tutorial-staging'
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_STAGING }}
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build_and_publish.outputs.image_digest }}
        env:
          # Flask staging environment configuration
          FLASK_ENV: production
          FLASK_DEBUG: false
          PORT: 8000
          LOG_LEVEL: info
          TUTORIAL_ENVIRONMENT: staging
          GUNICORN_WORKERS: 2
          GUNICORN_TIMEOUT: 30
      
      # Step 5: Wait for deployment initialization
      - name: Wait for Deployment Initialization
        run: |
          echo "‚è≥ Waiting for Flask staging deployment to initialize..."
          echo "üéì Educational Note: Python applications may need longer startup time"
          sleep 45
          echo "‚úÖ Initialization wait completed"
      
      # Step 6: Staging health check validation
      - name: Health Check Validation
        id: health_check
        run: |
          STAGING_URL="https://flask-tutorial-staging.azurewebsites.net"
          MAX_ATTEMPTS=12
          ATTEMPT=1
          
          echo "üè• Starting staging health check validation"
          echo "üéØ Target URL: $STAGING_URL/hello"
          echo "üéì Educational Note: Testing Flask /hello endpoint"
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "üîç Health check attempt $ATTEMPT/$MAX_ATTEMPTS"
            
            if curl -f -s --max-time 15 "$STAGING_URL/hello" > /dev/null; then
              echo "‚úÖ Staging health check successful"
              echo "health_status=healthy" >> $GITHUB_OUTPUT
              break
            else
              echo "‚ùå Health check failed, retrying in 20 seconds..."
              sleep 20
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done
          
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "üí• Staging health check failed after $MAX_ATTEMPTS attempts"
            echo "health_status=unhealthy" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      # Step 7: Comprehensive smoke tests
      - name: Run Staging Smoke Tests
        id: smoke_tests
        run: |
          echo "üß™ Running staging smoke tests for Flask application"
          STAGING_URL="https://flask-tutorial-staging.azurewebsites.net"
          
          # Test 1: Basic endpoint functionality
          echo "üìù Test 1: Flask endpoint response validation"
          RESPONSE=$(curl -s "$STAGING_URL/hello")
          EXPECTED='{"message":"Hello world"}'
          if echo "$RESPONSE" | grep -q "Hello world"; then
            echo "‚úÖ Endpoint response test passed: $RESPONSE"
          else
            echo "‚ùå Endpoint response test failed: '$RESPONSE'"
            exit 1
          fi
          
          # Test 2: HTTP status code validation
          echo "üìù Test 2: HTTP status code validation"
          STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/hello")
          if [ "$STATUS_CODE" = "200" ]; then
            echo "‚úÖ Status code test passed"
          else
            echo "‚ùå Status code test failed: $STATUS_CODE"
            exit 1
          fi
          
          # Test 3: Content-Type header validation
          echo "üìù Test 3: Content-Type header validation"
          CONTENT_TYPE=$(curl -s -I "$STAGING_URL/hello" | grep -i content-type | cut -d' ' -f2 | tr -d '\r\n')
          if echo "$CONTENT_TYPE" | grep -q "application/json"; then
            echo "‚úÖ Content-Type test passed: $CONTENT_TYPE"
          else
            echo "‚ùå Content-Type test failed: $CONTENT_TYPE"
            exit 1
          fi
          
          # Test 4: Response time performance
          echo "üìù Test 4: Response time performance"
          RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "$STAGING_URL/hello")
          if (( $(echo "$RESPONSE_TIME < 3.0" | bc -l) )); then
            echo "‚úÖ Response time test passed: ${RESPONSE_TIME}s"
          else
            echo "‚ö†Ô∏è Response time test warning: ${RESPONSE_TIME}s (>3s)"
          fi
          
          # Test 5: Health endpoint validation
          echo "üìù Test 5: Health endpoint validation"
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/health")
          if [ "$HEALTH_STATUS" = "200" ]; then
            echo "‚úÖ Health endpoint test passed"
          else
            echo "‚ùå Health endpoint test failed: $HEALTH_STATUS"
            exit 1
          fi
          
          # Test 6: Error handling validation
          echo "üìù Test 6: Error handling validation"
          ERROR_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/nonexistent")
          if [ "$ERROR_STATUS" = "404" ]; then
            echo "‚úÖ Error handling test passed"
          else
            echo "‚ùå Error handling test failed: $ERROR_STATUS"
            exit 1
          fi
          
          echo "üéâ All staging smoke tests completed successfully"
          echo "üéì Educational Note: Flask application passes all validation tests"
      
      # Step 8: Deployment success notification
      - name: Staging Deployment Success
        run: |
          echo "üöÄ Staging Deployment Completed Successfully"
          echo ""
          echo "üìä Deployment Summary:"
          echo "  ‚Ä¢ Environment: Staging"
          echo "  ‚Ä¢ URL: https://flask-tutorial-staging.azurewebsites.net"
          echo "  ‚Ä¢ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build_and_publish.outputs.image_digest }}"
          echo "  ‚Ä¢ Health Status: ${{ steps.health_check.outputs.health_status }}"
          echo "  ‚Ä¢ Smoke Tests: Passed"
          echo "  ‚Ä¢ Runtime: Python 3.12 + Flask 3.1.1"
          echo "  ‚Ä¢ WSGI Server: Gunicorn"
          echo ""
          echo "‚úÖ Ready for production deployment approval"

  # ===========================================================================
  # JOB 4: PRODUCTION ENVIRONMENT DEPLOYMENT
  # ===========================================================================
  # Production deployment with enhanced monitoring and rollback capabilities
  # Conditional execution based on release events or manual approval
  
  deploy_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 18
    needs: [build_and_publish, security_scan, deploy_staging]
    
    # Production deployment conditions
    if: >
      (github.event_name == 'release' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    
    # Environment configuration with production protection rules
    environment:
      name: production
      url: https://flask-tutorial.azurewebsites.net
    
    # Production deployment outputs
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
      production_url: ${{ steps.deploy.outputs.url }}
      rollback_required: ${{ steps.monitoring.outputs.rollback_required }}
    
    steps:
      # Step 1: Repository checkout for production deployment
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      # Step 2: Validate staging deployment success
      - name: Validate Staging Prerequisites
        run: |
          echo "üîç Validating staging deployment prerequisites"
          
          # Verify staging deployment was successful
          if [ "${{ needs.deploy_staging.outputs.deployment_status }}" != "success" ]; then
            echo "‚ùå Staging deployment validation failed"
            exit 1
          fi
          
          # Verify security scan passed
          if [ "${{ needs.security_scan.outputs.scan_result }}" = "failed" ]; then
            echo "‚ùå Security scan validation failed"
            exit 1
          fi
          
          echo "‚úÖ All production prerequisites validated"
          echo "üéì Educational Note: Production deployment requires staging validation"
      
      # Step 3: Setup Python for production smoke testing
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: 'requirements.txt'
      
      # Step 4: Install dependencies for production testing
      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          echo "üì¶ Production dependencies installed"
          echo "üéì Educational Note: Same dependencies used in production container"
      
      # Step 5: Deploy to production environment
      - name: Deploy to Azure Web App Production
        id: deploy
        uses: azure/webapps-deploy@v2
        with:
          app-name: 'flask-tutorial-production'
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_PRODUCTION }}
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build_and_publish.outputs.image_digest }}
        env:
          # Flask production environment configuration
          FLASK_ENV: production
          FLASK_DEBUG: false
          PORT: 8000
          LOG_LEVEL: info
          TUTORIAL_ENVIRONMENT: production
          GUNICORN_WORKERS: 4
          GUNICORN_TIMEOUT: 30
          GUNICORN_KEEPALIVE: 2
          GUNICORN_MAX_REQUESTS: 1000
          GUNICORN_MAX_REQUESTS_JITTER: 100
      
      # Step 6: Production deployment warm-up period
      - name: Production Warm-up Period
        run: |
          echo "üî• Production deployment warm-up period"
          echo "‚è≥ Allowing 75 seconds for Flask application initialization..."
          echo "üéì Educational Note: Gunicorn workers need time to start"
          sleep 75
          echo "‚úÖ Warm-up completed"
      
      # Step 7: Comprehensive production health validation
      - name: Production Health Validation
        id: health_validation
        run: |
          PRODUCTION_URL="https://flask-tutorial.azurewebsites.net"
          MAX_ATTEMPTS=18
          ATTEMPT=1
          
          echo "üè• Starting comprehensive production health validation"
          echo "üéØ Target URL: $PRODUCTION_URL/hello"
          echo "üéì Educational Note: Validating Flask production deployment"
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "üîç Health validation attempt $ATTEMPT/$MAX_ATTEMPTS"
            
            # Multiple validation checks
            if curl -f -s --max-time 20 "$PRODUCTION_URL/hello" > /dev/null; then
              # Validate response content
              RESPONSE=$(curl -s "$PRODUCTION_URL/hello")
              if echo "$RESPONSE" | grep -q "Hello world"; then
                echo "‚úÖ Production health validation successful"
                echo "health_status=healthy" >> $GITHUB_OUTPUT
                break
              else
                echo "‚ö†Ô∏è Response validation failed: '$RESPONSE'"
              fi
            else
              echo "‚ùå Health check failed, retrying in 25 seconds..."
            fi
            
            sleep 25
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "üí• Production health validation failed after $MAX_ATTEMPTS attempts"
            echo "health_status=unhealthy" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      # Step 8: Production smoke tests and monitoring
      - name: Production Smoke Tests
        id: production_tests
        run: |
          echo "üß™ Running comprehensive production smoke tests"
          PRODUCTION_URL="https://flask-tutorial.azurewebsites.net"
          
          # Test 1: Endpoint functionality validation
          echo "üìù Test 1: Production Flask endpoint functionality"
          RESPONSE=$(curl -s "$PRODUCTION_URL/hello")
          if echo "$RESPONSE" | grep -q "Hello world"; then
            echo "‚úÖ Production endpoint test passed: $RESPONSE"
          else
            echo "‚ùå Production endpoint test failed: '$RESPONSE'"
            exit 1
          fi
          
          # Test 2: Performance benchmarking
          echo "üìù Test 2: Production performance benchmarking"
          TOTAL_TIME=0
          REQUESTS=10
          
          for i in $(seq 1 $REQUESTS); do
            RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "$PRODUCTION_URL/hello")
            TOTAL_TIME=$(echo "$TOTAL_TIME + $RESPONSE_TIME" | bc -l)
            echo "  Request $i: ${RESPONSE_TIME}s"
          done
          
          AVERAGE_TIME=$(echo "scale=3; $TOTAL_TIME / $REQUESTS" | bc -l)
          echo "üìä Average response time: ${AVERAGE_TIME}s"
          
          if (( $(echo "$AVERAGE_TIME < 1.5" | bc -l) )); then
            echo "‚úÖ Performance test passed"
          else
            echo "‚ö†Ô∏è Performance test warning: ${AVERAGE_TIME}s (>1.5s)"
          fi
          
          # Test 3: Load testing simulation
          echo "üìù Test 3: Basic load testing with Flask"
          for i in {1..15}; do
            curl -s "$PRODUCTION_URL/hello" > /dev/null &
          done
          wait
          echo "‚úÖ Basic load test completed"
          
          # Test 4: Error handling in production
          echo "üìù Test 4: Production error handling"
          ERROR_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PRODUCTION_URL/nonexistent")
          if [ "$ERROR_STATUS" = "404" ]; then
            echo "‚úÖ Production error handling test passed"
          else
            echo "‚ùå Production error handling test failed: $ERROR_STATUS"
            exit 1
          fi
          
          # Test 5: Health endpoint validation
          echo "üìù Test 5: Production health endpoint"
          HEALTH_RESPONSE=$(curl -s "$PRODUCTION_URL/health")
          if echo "$HEALTH_RESPONSE" | grep -q "healthy"; then
            echo "‚úÖ Health endpoint test passed"
          else
            echo "‚ùå Health endpoint test failed: $HEALTH_RESPONSE"
            exit 1
          fi
          
          echo "üéâ All production smoke tests completed successfully"
          echo "üéì Educational Note: Flask application demonstrates production readiness"
      
      # Step 9: Production monitoring validation
      - name: Production Monitoring
        id: monitoring
        run: |
          echo "üìä Starting production monitoring validation"
          PRODUCTION_URL="https://flask-tutorial.azurewebsites.net"
          MONITORING_DURATION=360  # 6 minutes
          CHECK_INTERVAL=30        # 30 seconds
          CHECKS=$((MONITORING_DURATION / CHECK_INTERVAL))
          FAILED_CHECKS=0
          
          echo "‚è±Ô∏è Monitoring for $MONITORING_DURATION seconds ($CHECKS checks)"
          echo "üéì Educational Note: Extended monitoring for Python memory patterns"
          
          for i in $(seq 1 $CHECKS); do
            echo "üîç Monitoring check $i/$CHECKS"
            
            if ! curl -f -s --max-time 15 "$PRODUCTION_URL/hello" > /dev/null; then
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
              echo "‚ùå Monitoring check failed ($FAILED_CHECKS failures)"
            else
              echo "‚úÖ Monitoring check passed"
            fi
            
            # Rollback trigger: >20% failure rate
            FAILURE_RATE=$(echo "scale=2; $FAILED_CHECKS * 100 / $i" | bc -l)
            if (( $(echo "$FAILURE_RATE > 20" | bc -l) )); then
              echo "üö® CRITICAL: Failure rate ${FAILURE_RATE}% exceeds 20% threshold"
              echo "rollback_required=true" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            sleep $CHECK_INTERVAL
          done
          
          echo "üìà Production monitoring completed successfully"
          echo "üìä Final failure rate: $(echo "scale=2; $FAILED_CHECKS * 100 / $CHECKS" | bc -l)%"
          echo "rollback_required=false" >> $GITHUB_OUTPUT
          echo "üéì Educational Note: Flask application shows stable performance"
      
      # Step 10: Production deployment success notification
      - name: Production Deployment Success
        run: |
          echo "üéâ Production Deployment Completed Successfully"
          echo ""
          echo "üìä Production Deployment Summary:"
          echo "  ‚Ä¢ Environment: Production"
          echo "  ‚Ä¢ URL: https://flask-tutorial.azurewebsites.net"
          echo "  ‚Ä¢ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build_and_publish.outputs.image_digest }}"
          echo "  ‚Ä¢ Health Status: ${{ steps.health_validation.outputs.health_status }}"
          echo "  ‚Ä¢ Monitoring: ${{ steps.monitoring.outputs.rollback_required == 'false' && 'Stable' || 'Issues Detected' }}"
          echo "  ‚Ä¢ Version: ${{ needs.build_and_publish.outputs.deployment_version }}"
          echo "  ‚Ä¢ Runtime: Python 3.12 + Flask 3.1.1"
          echo "  ‚Ä¢ WSGI Server: Gunicorn with 4 workers"
          echo ""
          echo "üöÄ Flask tutorial application successfully deployed to production!"
          echo "üìö Educational deployment pipeline demonstration completed"
          echo ""
          echo "üîó Access the application:"
          echo "  ‚Ä¢ Production: https://flask-tutorial.azurewebsites.net/hello"
          echo "  ‚Ä¢ Staging: https://flask-tutorial-staging.azurewebsites.net/hello"

  # ===========================================================================
  # JOB 5: DEPLOYMENT NOTIFICATION AND REPORTING
  # ===========================================================================
  # Comprehensive deployment reporting and notification system
  # Educational demonstration of deployment communication and documentation
  
  deployment_notification:
    name: Deployment Notification
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [build_and_publish, security_scan, deploy_staging, deploy_production]
    if: always()  # Run regardless of previous job status
    
    steps:
      # Step 1: Repository checkout for reporting context
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      # Step 2: Generate comprehensive deployment report
      - name: Generate Deployment Report
        id: report
        run: |
          echo "üìã Generating comprehensive deployment report"
          
          # Deployment status evaluation
          BUILD_STATUS="${{ needs.build_and_publish.result }}"
          SECURITY_STATUS="${{ needs.security_scan.result }}"
          STAGING_STATUS="${{ needs.deploy_staging.result }}"
          PRODUCTION_STATUS="${{ needs.deploy_production.result }}"
          
          # Overall deployment status
          if [ "$BUILD_STATUS" = "success" ] && [ "$STAGING_STATUS" = "success" ]; then
            if [ "$PRODUCTION_STATUS" = "success" ]; then
              OVERALL_STATUS="‚úÖ SUCCESS - Full Flask deployment completed"
            elif [ "$PRODUCTION_STATUS" = "skipped" ]; then
              OVERALL_STATUS="üéØ PARTIAL - Staging Flask deployment successful"
            else
              OVERALL_STATUS="‚ö†Ô∏è WARNING - Production Flask deployment failed"
            fi
          else
            OVERALL_STATUS="‚ùå FAILED - Flask deployment pipeline failed"
          fi
          
          # Generate detailed report
          cat > deployment-report.md << EOF
          # üöÄ Python Flask Tutorial Deployment Report
          
          **Deployment Date:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')  
          **Workflow:** ${{ github.workflow }}  
          **Trigger:** ${{ github.event_name }}  
          **Branch:** ${{ github.ref_name }}  
          **Commit:** ${{ github.sha }}  
          
          ## üìä Overall Status
          $OVERALL_STATUS
          
          ## üîß Pipeline Results
          | Job | Status | Duration | Details |
          |-----|--------|----------|---------|
          | üèóÔ∏è Build & Publish | $BUILD_STATUS | - | Python Docker image build and registry push |
          | üîí Security Scan | $SECURITY_STATUS | - | Container + Python security assessment |
          | üß™ Deploy Staging | $STAGING_STATUS | - | Flask staging environment deployment |
          | üöÄ Deploy Production | $PRODUCTION_STATUS | - | Flask production environment deployment |
          
          ## üì¶ Artifacts
          | Type | Details |
          |------|---------|
          | Docker Image | \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build_and_publish.outputs.image_digest }}\` |
          | Flask Version | ${{ needs.build_and_publish.outputs.deployment_version }} |
          | Python Runtime | 3.12+ |
          | Base Image | python:3.12-alpine |
          | WSGI Server | Gunicorn |
          | Platforms | linux/amd64, linux/arm64 |
          
          ## üåê Environment URLs
          | Environment | URL | Status |
          |-------------|-----|--------|
          | Staging | https://flask-tutorial-staging.azurewebsites.net | ${{ needs.deploy_staging.result == 'success' && 'üü¢ Active' || 'üî¥ Inactive' }} |
          | Production | https://flask-tutorial.azurewebsites.net | ${{ needs.deploy_production.result == 'success' && 'üü¢ Active' || 'üî¥ Inactive' }} |
          
          ## üîí Security Summary
          | Metric | Count |
          |--------|-------|
          | Critical Vulnerabilities | ${{ needs.security_scan.outputs.critical_count || 'N/A' }} |
          | High Vulnerabilities | ${{ needs.security_scan.outputs.high_count || 'N/A' }} |
          | Python Security Issues | ${{ needs.security_scan.outputs.python_security_issues || 'N/A' }} |
          | Security Gate | ${{ needs.security_scan.outputs.scan_result || 'N/A' }} |
          
          ## üìö Educational Learning Points
          - ‚úÖ Python Flask multi-environment deployment strategy
          - ‚úÖ Container security scanning with Python-specific tools
          - ‚úÖ Automated health checks and Gunicorn monitoring
          - ‚úÖ GitHub Actions workflow orchestration
          - ‚úÖ Docker multi-platform Python image building
          - ‚úÖ Production deployment safety measures with WSGI
          - ‚úÖ Bandit and Safety Python security integration
          - ‚úÖ Flask application factory deployment patterns
          
          ## üîó Resources
          - [GitHub Repository](${{ github.server_url }}/${{ github.repository }})
          - [Container Registry](https://ghcr.io/${{ github.repository }})
          - [Security Reports](${{ github.server_url }}/${{ github.repository }}/security)
          - [Actions Workflow](${{ github.server_url }}/${{ github.repository }}/actions)
          
          ---
          *Generated by Python Flask Tutorial CD Pipeline v2.0.0*
          EOF
          
          echo "üìÑ Deployment report generated successfully"
      
      # Step 3: Upload deployment report artifact
      - name: Upload Deployment Report
        uses: actions/upload-artifact@v3
        with:
          name: flask-deployment-report
          path: deployment-report.md
          retention-days: 90
      
      # Step 4: Display deployment summary
      - name: Display Deployment Summary
        run: |
          echo "üìã FLASK DEPLOYMENT PIPELINE SUMMARY"
          echo "====================================="
          echo ""
          echo "üèóÔ∏è Build & Publish: ${{ needs.build_and_publish.result }}"
          echo "üîí Security Scan: ${{ needs.security_scan.result }}"
          echo "üß™ Staging Deploy: ${{ needs.deploy_staging.result }}"
          echo "üöÄ Production Deploy: ${{ needs.deploy_production.result }}"
          echo ""
          echo "üì¶ Docker Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          echo "üè∑Ô∏è Flask Version: ${{ needs.build_and_publish.outputs.deployment_version }}"
          echo "üêç Python Runtime: 3.12+"
          echo "üöÄ WSGI Server: Gunicorn"
          echo ""
          echo "üåê Application URLs:"
          if [ "${{ needs.deploy_staging.result }}" = "success" ]; then
            echo "  ‚Ä¢ Staging: https://flask-tutorial-staging.azurewebsites.net/hello"
          fi
          if [ "${{ needs.deploy_production.result }}" = "success" ]; then
            echo "  ‚Ä¢ Production: https://flask-tutorial.azurewebsites.net/hello"
          fi
          echo ""
          echo "üìö Educational Flask CD Pipeline Demonstration Complete!"

# =============================================================================
# EDUCATIONAL DEPLOYMENT PIPELINE SUMMARY
# =============================================================================
# This Continuous Deployment pipeline demonstrates comprehensive container 
# deployment patterns for the Python Flask tutorial application, showcasing:
#
# üèóÔ∏è CONTAINER BUILD AUTOMATION:
#   - Multi-platform Docker image building (linux/amd64, linux/arm64)
#   - GitHub Container Registry integration (ghcr.io)
#   - Semantic versioning and metadata management with python suffix
#   - Build optimization with pip caching and layer optimization
#   - Educational container labeling and Flask documentation
#
# üîí SECURITY INTEGRATION:
#   - Trivy vulnerability scanning for Python container images
#   - Bandit static security analysis for Python code
#   - Safety dependency vulnerability assessment for pip packages
#   - SARIF security reporting to GitHub Security tab
#   - Security gate validation with Python-specific thresholds
#   - Container provenance and SBOM generation for pip packages
#
# üöÄ MULTI-ENVIRONMENT FLASK DEPLOYMENT:
#   - Automated Flask staging environment deployment
#   - Production Flask deployment with manual approval gates
#   - Azure Web Apps container deployment with Python runtime
#   - Environment-specific Flask configuration management
#   - Educational Flask deployment strategy demonstration
#
# üè• HEALTH MONITORING & VALIDATION:
#   - Comprehensive Flask health check implementation
#   - Smoke testing for Flask endpoint validation
#   - Performance benchmarking and load testing for Python apps
#   - Production monitoring with Gunicorn-aware rollback triggers
#   - Educational monitoring patterns and Flask alerting
#
# üìä DEPLOYMENT REPORTING:
#   - Comprehensive Flask deployment status reporting
#   - Artifact management and version tracking with python suffixes
#   - Educational Flask deployment documentation
#   - GitHub Actions workflow integration
#   - Deployment history and audit trail
#
# üéì EDUCATIONAL FEATURES:
#   - Clear logging and status reporting throughout Flask pipeline
#   - Comprehensive documentation and Python learning points
#   - Production-ready patterns in educational Flask context
#   - Container deployment best practices for Python applications
#   - CI/CD pipeline integration and orchestration for Flask
#
# This pipeline serves as both a functional deployment system and an 
# educational demonstration of modern Python container deployment practices,
# Flask security integration, and production deployment strategies for the
# Python Flask tutorial application with Flask v3.1.1 and Gunicorn WSGI server.
# =============================================================================